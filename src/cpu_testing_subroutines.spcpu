.include "../include/spcpu_ca65_macro_pack.spinc"
.include "test_var_stuff.spinc"
.include "misc_utility_macros.spinc"



;.export do_32_bit_add
;.export do_32_bit_subtract

.export test_ldst
.export test_ldst_and_push_pop

.export test_32_bit_add
.export test_32_bit_subtract

.export test_32_bit_add_immediate
.export test_32_bit_subtract_immediate

.export test_addpb
.export test_subpb
.export test_and_orr_inv


.segment "ROM"



.macro testing_good_and_bad
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
.endmac





test_ldst:
	multi_push_regs convert_pair_to_two_regs{r4p}, r6
	
	cpypi r2p, some_arr
	cpypi r4p, $0002
	
	str r0, r2p
	strxi r0, r2p, $0001
	strx r0, r2p, r4p
	
	ldr r6, r2p
	cmp r6, r0
	bne @bad
	
	ldrxi r6, r2p, $0001
	cmp r6, r0
	bne @bad
	
	ldrx r6, r2p, r4p
	cmp r6, r0
	bne @bad
	
	
	
testing_good_and_bad
	
@done:
	multi_pop_regs convert_pair_to_two_regs{r4p}, r6
	
	basic_ret


test_ldst_and_push_pop:
	cpypi r4p, $4455
	cpyi r6, $66
	
	; Tail call optimization
	jumpi test_ldst






test_math_val_a_0 = $ffbbaa33
test_math_val_b_0 = $10fba3dc

test_math_val_a_1 = $a98f1d23
test_math_val_b_1 = test_math_val_a_1 + 30

test_math_val_a_2 = test_math_val_b_0 + $12000000
test_math_val_b_2 = test_math_val_b_1 + $30000000

test_math_val_a_3 = $83abcdab
test_math_val_b_3 = test_math_val_b_2 + $30000000

test_math_val_a_4 = $85abcdab
test_math_val_b_4 = test_math_val_b_3 + $56a80003



add32_result_0 = test_math_val_a_0 + test_math_val_b_0
add32_result_1 = test_math_val_a_1 + test_math_val_b_1
add32_result_2 = test_math_val_a_2 + test_math_val_b_2
add32_result_3 = test_math_val_a_3 + test_math_val_b_3

sub32_result_0 = test_math_val_a_0 - test_math_val_b_0
sub32_result_1 = test_math_val_a_1 - test_math_val_b_1
sub32_result_2 = test_math_val_a_2 - test_math_val_b_2
sub32_result_3 = test_math_val_a_3 - test_math_val_b_3


test_math_val_a_table:
	.dbyt convert_iv_32_to_words{test_math_val_a_0}
	.dbyt convert_iv_32_to_words{test_math_val_a_1}
	.dbyt convert_iv_32_to_words{test_math_val_a_2}
	.dbyt convert_iv_32_to_words{test_math_val_a_3}

test_math_val_b_table:
	.dbyt convert_iv_32_to_words{test_math_val_b_0}
	.dbyt convert_iv_32_to_words{test_math_val_b_1}
	.dbyt convert_iv_32_to_words{test_math_val_b_2}
	.dbyt convert_iv_32_to_words{test_math_val_b_3}

add32_result_table:
	.dbyt convert_iv_32_to_words{add32_result_0}
	.dbyt convert_iv_32_to_words{add32_result_1}
	.dbyt convert_iv_32_to_words{add32_result_2}
	.dbyt convert_iv_32_to_words{add32_result_3}

sub32_result_table:
	.dbyt convert_iv_32_to_words{sub32_result_0}
	.dbyt convert_iv_32_to_words{sub32_result_1}
	.dbyt convert_iv_32_to_words{sub32_result_2}
	.dbyt convert_iv_32_to_words{sub32_result_3}
sub32_result_table_end:

test_math_table_size = ( sub32_result_table_end - sub32_result_table )



test_32_bit_add:
	multi_push_pairs r4p, r6p, r8p
	
	; Clear the counter
	cpypi r8p, $0000
	
@loop:
	ldpxi r0p, r8p, test_math_val_a_table
	ldpxi r4p, r8p, test_math_val_b_table
	
	ldpxi r2p, r8p, test_math_val_a_table + num_bytes_1_pair
	ldpxi r6p, r8p, test_math_val_b_table + num_bytes_1_pair
	
	
	add32 r0p, r2p, r4p, r6p
	
	ldpxi r4p, r8p, add32_result_table
	ldpxi r6p, r8p, add32_result_table + num_bytes_1_pair
	
	branch_ne_32 r0p, r2p, r4p, r6p, @bad
	
	; Continue the loop
	addpbi r8p, num_bytes_2_pair
	branch_ne_16_imm r8p, test_math_table_size, @loop
	
	
testing_good_and_bad
	
@done:
	multi_pop_pairs r4p, r6p, r8p
	basic_ret


test_32_bit_subtract:
	multi_push_pairs r4p, r6p, r8p
	
	; Clear the counter
	cpypi r8p, $0000
	
@loop:
	ldpxi r0p, r8p, test_math_val_a_table
	ldpxi r4p, r8p, test_math_val_b_table
	
	ldpxi r2p, r8p, test_math_val_a_table + num_bytes_1_pair
	ldpxi r6p, r8p, test_math_val_b_table + num_bytes_1_pair
	
	
	sub32 r0p, r2p, r4p, r6p
	
	ldpxi r4p, r8p, sub32_result_table
	ldpxi r6p, r8p, sub32_result_table + num_bytes_1_pair
	
	branch_ne_32 r0p, r2p, r4p, r6p, @bad
	
	; Continue the loop
	addpbi r8p, num_bytes_2_pair
	branch_ne_16_imm r8p, test_math_table_size, @loop
	
	
testing_good_and_bad
	
@done:
	multi_pop_pairs r4p, r6p, r8p
	basic_ret




.macro totally_immediate_add32 rAp, rBp, imm_value_32_a, imm_value_32_b
	error_if_bad_reg_pair_name rAp
	error_if_bad_reg_pair_name rBp
	
	cpypi rAp, .hiword(imm_value_32_a)
	cpypi rBp, .loword(imm_value_32_a)
	add32i rAp, rBp, imm_value_32_b
	
.endmac


.macro totally_immediate_sub32 rAp, rBp, imm_value_32_a, imm_value_32_b
	error_if_bad_reg_pair_name rAp
	error_if_bad_reg_pair_name rBp
	
	cpypi rAp, .hiword(imm_value_32_a)
	cpypi rBp, .loword(imm_value_32_a)
	sub32i rAp, rBp, imm_value_32_b
	
.endmac


test_32_bit_add_immediate:
	totally_immediate_add32 r0p, r2p, test_math_val_a_0, test_math_val_b_0
	branch_ne_32_imm r0p, r2p, add32_result_0, @bad
	
	totally_immediate_add32 r0p, r2p, test_math_val_a_1, test_math_val_b_1
	branch_ne_32_imm r0p, r2p, add32_result_1, @bad
	
	totally_immediate_add32 r0p, r2p, test_math_val_a_2, test_math_val_b_2
	branch_ne_32_imm r0p, r2p, add32_result_2, @bad
	
	totally_immediate_add32 r0p, r2p, test_math_val_a_3, test_math_val_b_3
	branch_ne_32_imm r0p, r2p, add32_result_3, @bad
	
testing_good_and_bad
	
@done:
	basic_ret




test_32_bit_subtract_immediate:
	totally_immediate_sub32 r0p, r2p, test_math_val_a_0, test_math_val_b_0
	branch_ne_32_imm r0p, r2p, sub32_result_0, @bad
	
	totally_immediate_sub32 r0p, r2p, test_math_val_a_1, test_math_val_b_1
	branch_ne_32_imm r0p, r2p, sub32_result_1, @bad
	
	totally_immediate_sub32 r0p, r2p, test_math_val_a_2, test_math_val_b_2
	branch_ne_32_imm r0p, r2p, sub32_result_2, @bad
	
	totally_immediate_sub32 r0p, r2p, test_math_val_a_3, test_math_val_b_3
	branch_ne_32_imm r0p, r2p, sub32_result_3, @bad
	
testing_good_and_bad
	
@done:
	basic_ret







test_addpb:
	
	; Use r2p as outer loop counter
	.define i r2p
	; Use r4 as inner loop counter
	.define j r4
	
	;multi_push_pairs r4p, r6p
	multi_push_regs r4, convert_pair_to_two_regs{r6p}
	
	
	
;for ( int i=0; i<0x10000; ++i )
	cpypi i, $0000
@outer_loop:
	
	
	;	for ( int j=0; j<0x100; ++j )
	cpyi j, $00
	@inner_loop:
		
		cpyp r0p, i
		addpb r0p, j
		
		cpyi r6, $00
		cpy r7, j
		
		
		push_pair i
		addp i, r6p
		cmpp r0p, i
		pop_pair i
		
		bne @bad
		
		inc j
		bcc @inner_loop
	
	
	incp i
	bcc @outer_loop
	
testing_good_and_bad
	
@done:
	;multi_pop_pairs r4p, r6p
	multi_pop_regs r4, convert_pair_to_two_regs{r6p}
	basic_ret
	
	.undef i
	.undef j


test_subpb:
	
	; Use r2p as outer loop counter
	.define i r2p
	; Use r4 as inner loop counter
	.define j r4
	
	;multi_push_pairs r4p, r6p
	multi_push_regs r4, convert_pair_to_two_regs{r6p}
	
	
	
;for ( int i=0; i<0x10000; ++i )
	cpypi i, $0000
@outer_loop:
	
	
	;	for ( int j=0; j<0x100; ++j )
	cpyi j, $00
	@inner_loop:
		
		cpyp r0p, i
		subpb r0p, j
		
		cpyi r6, $00
		cpy r7, j
		
		
		push_pair i
		subp i, r6p
		cmpp r0p, i
		pop_pair i
		
		bne @bad
		
		inc j
		bcc @inner_loop
	
	
	incp i
	bcc @outer_loop
	
testing_good_and_bad
	
@done:
	;multi_pop_pairs r4p, r6p
	multi_pop_regs r4, convert_pair_to_two_regs{r6p}
	basic_ret
	
	.undef i
	.undef j



test_and_orr_inv:
	
	.define i r1
	.define j r2
	
	
	
	
testing_good_and_bad
	
@done:
	basic_ret
	
	.undef i
	.undef j



