.include "../include/spcpu_ca65_macro_pack.spinc"
.include "test_var_stuff.spinc"
.include "misc_utility_macros.spinc"



;.export do_32_bit_add
;.export do_32_bit_subtract
.export test_math_val_a_table
.export test_math_val_b_table
.export add32_result_table
.export sub32_result_table

.export test_ldst
.export test_ldst_and_push_pop

.export test_32_bit_add
.export test_32_bit_subtract

.export test_32_bit_add_immediate
.export test_32_bit_subtract_immediate

.export test_addpb
.export test_subpb
.export test_and_orr_inv_invp
.export test_xor


.segment "ROM"






test_ldst:
	;multi_push_regs convert_pair_to_two_regs{r4p}, r6, r7, r8
	
	cpypi r2p, some_arr
	cpypi r4p, $0002
	
	str r0, r2p
	strxi r0, r2p, $0001
	strx r0, r2p, r4p
	
	ldr r6, r2p
	ldrxi r7, r2p, $0001
	ldrx r8, r2p, r4p
	
	
	cmp r6, r0
	bne @bad
	
	cmp r7, r0
	bne @bad
	
	cmp r8, r0
	bne @bad
	
	
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
	
@done:
	;multi_pop_regs convert_pair_to_two_regs{r4p}, r6, r7, r8
	
	basic_ret


test_ldst_and_push_pop:
	cpypi r4p, $4455
	cpyi r6, $66
	
	; Tail call optimization
	jumpi test_ldst






test_math_val_a_0 = $ffbbaa33
test_math_val_b_0 = $10fba3dc

test_math_val_a_1 = $a98f1d23
test_math_val_b_1 = test_math_val_a_1 + 30

test_math_val_a_2 = test_math_val_b_0 + $12000000
test_math_val_b_2 = test_math_val_b_1 + $30000000

test_math_val_a_3 = $83abcdab
test_math_val_b_3 = test_math_val_b_2 + $30000000

test_math_val_a_4 = $85abcdab
test_math_val_b_4 = test_math_val_b_3 + $56a80003



add32_result_0 = test_math_val_a_0 + test_math_val_b_0
add32_result_1 = test_math_val_a_1 + test_math_val_b_1
add32_result_2 = test_math_val_a_2 + test_math_val_b_2
add32_result_3 = test_math_val_a_3 + test_math_val_b_3

sub32_result_0 = test_math_val_a_0 - test_math_val_b_0
sub32_result_1 = test_math_val_a_1 - test_math_val_b_1
sub32_result_2 = test_math_val_a_2 - test_math_val_b_2
sub32_result_3 = test_math_val_a_3 - test_math_val_b_3


test_math_val_a_table:
	.dbyt convert_iv_32_to_words{test_math_val_a_0}
	.dbyt convert_iv_32_to_words{test_math_val_a_1}
	.dbyt convert_iv_32_to_words{test_math_val_a_2}
	.dbyt convert_iv_32_to_words{test_math_val_a_3}

test_math_val_b_table:
	.dbyt convert_iv_32_to_words{test_math_val_b_0}
	.dbyt convert_iv_32_to_words{test_math_val_b_1}
	.dbyt convert_iv_32_to_words{test_math_val_b_2}
	.dbyt convert_iv_32_to_words{test_math_val_b_3}

add32_result_table:
	.dbyt convert_iv_32_to_words{add32_result_0}
	.dbyt convert_iv_32_to_words{add32_result_1}
	.dbyt convert_iv_32_to_words{add32_result_2}
	.dbyt convert_iv_32_to_words{add32_result_3}

sub32_result_table:
	.dbyt convert_iv_32_to_words{sub32_result_0}
	.dbyt convert_iv_32_to_words{sub32_result_1}
	.dbyt convert_iv_32_to_words{sub32_result_2}
	.dbyt convert_iv_32_to_words{sub32_result_3}
sub32_result_table_end:

test_math_table_size = ( sub32_result_table_end - sub32_result_table )


test_32_bit_add:
	multi_push_pairs r4p, r6p, r8p
	
	; Clear the counter
	cpypi r8p, $0000
	
@loop:
	ldpxi r0p, r8p, test_math_val_a_table
	ldpxi r4p, r8p, test_math_val_b_table
	
	ldpxi r2p, r8p, test_math_val_a_table + num_bytes_1_pair
	ldpxi r6p, r8p, test_math_val_b_table + num_bytes_1_pair
	
	
	add32 r0p, r2p, r4p, r6p
	
	ldpxi r4p, r8p, add32_result_table
	ldpxi r6p, r8p, add32_result_table + num_bytes_1_pair
	
	branch_ne_32 r0p, r2p, r4p, r6p, @bad
	
	; Continue the loop
	addpbi r8p, num_bytes_2_pair
	branch_ne_16_imm r8p, test_math_table_size, @loop
	
	
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
	
@done:
	multi_pop_pairs r4p, r6p, r8p
	basic_ret


test_32_bit_subtract:
	multi_push_pairs r4p, r6p, r8p
	
	; Clear the counter
	cpypi r8p, $0000
	
@loop:
	ldpxi r0p, r8p, test_math_val_a_table
	ldpxi r4p, r8p, test_math_val_b_table
	
	ldpxi r2p, r8p, test_math_val_a_table + num_bytes_1_pair
	ldpxi r6p, r8p, test_math_val_b_table + num_bytes_1_pair
	
	
	sub32 r0p, r2p, r4p, r6p
	
	ldpxi r4p, r8p, sub32_result_table
	ldpxi r6p, r8p, sub32_result_table + num_bytes_1_pair
	
	branch_ne_32 r0p, r2p, r4p, r6p, @bad
	
	; Continue the loop
	addpbi r8p, num_bytes_2_pair
	branch_ne_16_imm r8p, test_math_table_size, @loop
	
	
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
	
@done:
	multi_pop_pairs r4p, r6p, r8p
	basic_ret




.macro totally_immediate_add32 rAp, rBp, imm_value_32_a, imm_value_32_b
	error_if_bad_reg_pair_name rAp
	error_if_bad_reg_pair_name rBp
	
	cpypi rAp, .hiword(imm_value_32_a)
	cpypi rBp, .loword(imm_value_32_a)
	add32i rAp, rBp, imm_value_32_b
	
.endmac


.macro totally_immediate_sub32 rAp, rBp, imm_value_32_a, imm_value_32_b
	error_if_bad_reg_pair_name rAp
	error_if_bad_reg_pair_name rBp
	
	cpypi rAp, .hiword(imm_value_32_a)
	cpypi rBp, .loword(imm_value_32_a)
	sub32i rAp, rBp, imm_value_32_b
	
.endmac


test_32_bit_add_immediate:
	totally_immediate_add32 r0p, r2p, test_math_val_a_0, test_math_val_b_0
	branch_ne_32_imm r0p, r2p, add32_result_0, @bad
	
	totally_immediate_add32 r0p, r2p, test_math_val_a_1, test_math_val_b_1
	branch_ne_32_imm r0p, r2p, add32_result_1, @bad
	
	totally_immediate_add32 r0p, r2p, test_math_val_a_2, test_math_val_b_2
	branch_ne_32_imm r0p, r2p, add32_result_2, @bad
	
	totally_immediate_add32 r0p, r2p, test_math_val_a_3, test_math_val_b_3
	branch_ne_32_imm r0p, r2p, add32_result_3, @bad
	
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
	
@done:
	basic_ret




test_32_bit_subtract_immediate:
	totally_immediate_sub32 r0p, r2p, test_math_val_a_0, test_math_val_b_0
	branch_ne_32_imm r0p, r2p, sub32_result_0, @bad
	
	totally_immediate_sub32 r0p, r2p, test_math_val_a_1, test_math_val_b_1
	branch_ne_32_imm r0p, r2p, sub32_result_1, @bad
	
	totally_immediate_sub32 r0p, r2p, test_math_val_a_2, test_math_val_b_2
	branch_ne_32_imm r0p, r2p, sub32_result_2, @bad
	
	totally_immediate_sub32 r0p, r2p, test_math_val_a_3, test_math_val_b_3
	branch_ne_32_imm r0p, r2p, sub32_result_3, @bad
	
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
	
@done:
	basic_ret







test_addpb:
	
	; Use r2p as outer loop counter
	.define i r2p
	; Use r4 as inner loop counter
	.define j r4
	
	;multi_push_pairs r4p, r6p
	multi_push_regs r4, convert_pair_to_two_regs{r6p}, \
		convert_pair_to_two_regs{r8p}
	
	
	
;for ( int i=0; i<0x10000; ++i )
	cpypi i, $0000
@outer_loop:
	
	
	;	for ( int j=0; j<0x100; ++j )
	cpyi j, $00
	@inner_loop:
		
		cpyp r0p, i
		addpb r0p, j
		
		cpyi r6, $00
		cpy r7, j
		
		cpyp r8p, i
		addp r8p, r6p
		cmpp r0p, r8p
		
		bne @bad
		
		inc j
		bcc @inner_loop
	
	
	incp i
	bcc @outer_loop
	
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
	
@done:
	;multi_pop_pairs r4p, r6p
	multi_pop_regs r4, convert_pair_to_two_regs{r6p}, \
		convert_pair_to_two_regs{r8p}
	basic_ret
	
	.undef i
	.undef j


test_subpb:
	
	; Use r2p as outer loop counter
	.define i r2p
	; Use r4 as inner loop counter
	.define j r4
	
	;multi_push_pairs r4p, r6p
	multi_push_regs r4, convert_pair_to_two_regs{r6p}, \
		convert_pair_to_two_regs{r8p}
	
	
	
;for ( int i=0; i<0x10000; ++i )
	cpypi i, $0000
@outer_loop:
	
	
	;	for ( int j=0; j<0x100; ++j )
	cpyi j, $00
	@inner_loop:
		
		cpyp r0p, i
		subpb r0p, j
		
		cpyi r6, $00
		cpy r7, j
		
		cpyp r8p, i
		subp r8p, r6p
		cmpp r0p, r8p
		
		bne @bad
		
		inc j
		bcc @inner_loop
	
	
	incp i
	bcc @outer_loop
	
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
	
@done:
	;multi_pop_pairs r4p, r6p
	multi_pop_regs r4, convert_pair_to_two_regs{r6p}, \
		convert_pair_to_two_regs{r8p}
	basic_ret
	
	.undef i
	.undef j



test_and_orr_inv_invp:
	
	.define ijp r2p
	.define i reg_pair_hi{ijp}
	.define j reg_pair_lo{ijp}
	
	push_pair r4p
	
	cpyi i, $00
@outer_loop:
	
	cpyi j, $00
	@inner_loop:
		cpy r0, i
		and r0, j
		
		
		cpyp r4p, ijp
		
		
		; NOR Logic AND
		invp r4p
		orr r4, r5
		inv r4
		
		
		cmp r0, r4
		bne @bad
		
		
		inc j
		bcc @inner_loop
	
	
	inc i
	bcc @outer_loop
	
	
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
	
@done:
	pop_pair r4p
	basic_ret
	
	.undef ijp
	.undef i
	.undef j


test_xor:
	
	.define ijp r2p
	.define i reg_pair_hi{ijp}
	.define j reg_pair_lo{ijp}
	
	push_pair r4p
	
	cpyi i, $00
@outer_loop:
	
	cpyi j, $00
	@inner_loop:
		cpy r0, i
		xor r0, j
		
		
		cpyp r4p, ijp
		
		
		; NOR Logic XOR
		cpy r1, r4
		and r1, r5
		
		orr r4, r5
		inv r4
		
		orr r4, r1
		inv r4
		
		
		cmp r0, r4
		bne @bad
		
		
		inc j
		bcc @inner_loop
	
	
	inc i
	bcc @outer_loop
	
	
@good:
	cpyi r0, $01
	bra @done
	
@bad:
	cpyi r0, $00
	
@done:
	pop_pair r4p
	basic_ret
	
	.undef ijp
	.undef i
	.undef j



