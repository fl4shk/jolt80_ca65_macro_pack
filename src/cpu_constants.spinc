.ifndef cpu_constants_spinc
cpu_constants_spinc = 3

.include "general_macros.spinc"

proc_flags_width = 2
proc_flags_msb_pos = width_to_msb_pos(proc_flags_width)


; General register constants

; 16 GPRs
cpu_num_regs = 16

; 8 GPR pairs
cpu_num_reg_pairs = 8


; Instruction encoding things
cpu_reg_index_ie_width = 4
cpu_reg_index_ie_msb_pos = width_to_msb_pos(cpu_reg_index_ie_width)

cpu_rp_index_ie_width = 3
cpu_rp_index_ie_msb_pos = width_to_msb_pos(cpu_rp_index_ie_width)


; Register widths and most significant bit positions
cpu_reg_width = 8
cpu_reg_msb_pos = width_to_msb_pos(cpu_reg_width)

cpu_rp_width = 16
cpu_rp_msb_pos = width_to_msb_pos(cpu_rp_width)

; Immediate value widths and most significant bit positions
cpu_imm_value_8_width = cpu_reg_width
cpu_imm_value_8_msb_pos = cpu_reg_msb_pos

cpu_imm_value_16_width = cpu_rp_width
cpu_imm_value_16_msb_pos = cpu_rp_msb_pos


; CPU Register array size stuff
cpu_reg_arr_width = 16
cpu_reg_arr_msb_pos = width_to_msb_pos(cpu_reg_arr_width)


; Non-instruction data in/out size stuff (8-bit because during instruction
; execution, the CPU can only load or store one byte at a time)
cpu_data_inout_8_width = cpu_reg_width
cpu_data_inout_8_msb_pos = cpu_reg_msb_pos

; Instruction data size stuff (16-bit
cpu_data_inout_16_width = cpu_rp_width
cpu_data_inout_16_msb_pos = cpu_rp_msb_pos



; Addressing stuff
cpu_addr_width = cpu_rp_width
cpu_addr_msb_pos = cpu_rp_msb_pos
 
; CPU state stuff
cpu_state_width = 4
cpu_state_msb_pos = width_to_msb_pos(cpu_state_width)


r0 = 0
r1 = 1
r2 = 2
r3 = 3
r4 = 4
r5 = 5
r6 = 6
r7 = 7
r8 = 8
r9 = 9
r10 = 10
r11 = 11
r12 = 12
r13 = 13
r14 = 14
r15 = 15


; REQUIRE the use of the "p" character, or use the "lr" or "pc" special
; registers
r0p = r15 + 2
r2p = r15 + 4
r4p = r15 + 6
r6p = r15 + 8
r8p = r15 + 10
r10p = r15 + 12
r12p = r15 + 14
r14p = r15 + 16
lr = r12p
pc = r14p

; Get the ACTUAL encoding of a reg pair
.define encode_reg_pair( rAp ) ( (rAp) - r15 - 2 )



.endif		; cpu_constants_spinc
